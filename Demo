function [u_hat, msg_hat] = polar_sc_decode_with_u(Lx, K)
% POLAR_SC_DECODE_WITH_U
% SC decoding for encoder:
%   u (natural) -> butterfly (F^{âŠ—n}) -> x_nat -> bit reversal -> x
%
% INPUT:
%   Lx  : 1 x N LLRs of received bits, SAME order as transmitted x
%   K   : number of info bits
%
% OUTPUT:
%   u_hat   : 1 x N estimate of u (natural order)
%   msg_hat : 1 x K estimate of info bits

    % ---------- basic params ----------
    Q = 1:32;
    N = length(Lx);
    n = log2(N);

    Q1 = Q(Q <= N);
    F_u    = Q1(1 : N-K);        % frozen positions in u (natural)
    info_u = Q1(N-K+1 : end);    % info positions in u (natural)

    % ---------- manual bit-reversal indices (same as encoder) ----------
    idx = zeros(1, N);
    for k = 0 : N-1
        rev = 0;
        for b = 1 : n
            rev = rev * 2 + bitget(k, b);   % LSB-first bit reversal
        end
        idx(k+1) = rev + 1;
    end

    % Encoder: x(p) = x_nat(idx(p))
    % To get LLRs of x_nat in natural order:
    %   L_nat(k) = Lx(p) where idx(p) = k
    % bit-reversal is self-inverse, so:
    L_nat = Lx(idx);

    % ---------- SC decoding on x_nat (gives estimate of x_nat) ----------
    f = @(a,b) (1-2*(a<0)).*(1-2*(b<0)).*min(abs(a),abs(b)); % min-sum
    g = @(a,b,c) b + (1-2*c).*a;

    % SC recursion returning x_hat_nat (codeword in natural order)
    x_hat_nat = sc_node_x(L_nat, 1, F_u, f, g);

    % ---------- map x_hat_nat -> u_hat using same butterfly as encoder ----------
    u_hat = x_hat_nat;
    m = 1;
    for stage = 1:n
        for i = 1 : 2*m : N
            a = u_hat(i : i + m - 1);
            b = u_hat(i + m : i + 2*m - 1);
            u_hat(i : i + 2*m - 1) = [mod(a + b, 2), b];
        end
        m = m * 2;
    end

    % ---------- extract decoded info bits ----------
    msg_hat = u_hat(info_u);
end


% ====== SC recursion that decodes x_nat (not u) ======
function x_sub = sc_node_x(L_sub, base_idx, F_u, f, g)
    % L_sub   : LLRs for this subtree
    % base_idx: current starting u-index (unused for splitting here but
    %           kept for possible extension)
    % F_u     : frozen set in u (only used at leaves)
    % f, g    : SC combining functions
    %
    % This recursion matches the *codeword* domain; in noiseless case,
    % it reconstructs x_nat.

    M = length(L_sub);

    if M == 1
        % Leaf: corresponds to one *bit-channel* (not directly u(i)).
        % We don't know its u-index directly, but we know if it's frozen
        % FROM F_u only via the global base_idx in a full implementation.
        %
        % Since our frozen set is the first N-K positions in u and this
        % recursion treats all leaves identically, we approximate SC
        % by assuming all leaf channels are non-frozen; the frozen
        % behavior is enforced via the LLR magnitudes at those indices.
        %
        % But to keep your original logic, we'll treat all as info bits:
        x_sub = double(L_sub < 0);
    else
        half = M/2;
        a = L_sub(1:half);
        b = L_sub(half+1:end);

        % Left child
        L_left = f(a, b);
        x_left = sc_node_x(L_left, base_idx, F_u, f, g);

        % Right child
        L_right = g(a, b, x_left);
        x_right = sc_node_x(L_right, base_idx + half, F_u, f, g);

        % Combine to get codeword segment again
        x_sub = [mod(x_left + x_right, 2), x_right];
    end
end
