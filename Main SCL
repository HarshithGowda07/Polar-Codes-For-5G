function [u_hat, msg_hat] = polar_scl_decoder(Lx, K, L)
% ============================================================
% EXACT SUCCESSIVE CANCELLATION LIST (SCL) DECODER
% No CRC, exact tree-based implementation
% ============================================================

N = length(Lx);
n = log2(N);

% ---- Reliability (5G NR) ----
Q1024 = polar_reliability_1024();
Q = Q1024(Q1024 <= N);

frozen = true(1,N);
frozen(Q(N-K+1:end)) = false;

info_pos = Q(N-K+1:end);

% ---- Undo bit-reversal (encoder outputs bit-reversed) ----
idx = bitrevorder(0:N-1) + 1;
Lx = Lx(idx);

% ---- Initialize path list ----
paths = struct();
paths(1).LLR = zeros(n+1, N);
paths(1).BIT = zeros(n+1, N);
paths(1).PM  = 0;

paths(1).LLR(1,:) = Lx;
active = 1;

% ---- Bit-by-bit decoding ----
for phi = 1:N
    new_paths = [];

    for p = 1:active
        % Update LLR tree for this path
        paths(p).LLR = update_llr_tree(paths(p).LLR, paths(p).BIT, phi, n);
        Lval = paths(p).LLR(n+1, phi);

        if frozen(phi)
            % frozen → only 0
            paths(p).BIT(n+1, phi) = 0;
            paths(p).PM = paths(p).PM + max(0, -Lval);
            new_paths = [new_paths, paths(p)];
        else
            % information → split
            p0 = paths(p);
            p1 = paths(p);

            p0.BIT(n+1, phi) = 0;
            p1.BIT(n+1, phi) = 1;

            p0.PM = p0.PM + max(0, -Lval);
            p1.PM = p1.PM + max(0,  Lval);

            new_paths = [new_paths, p0, p1];
        end
    end

    % ---- Prune to best L paths ----
    PMs = [new_paths.PM];
    [~, order] = sort(PMs);
    paths = new_paths(order(1:min(L,length(order))));
    active = length(paths);

    % ---- Update partial sums for each path ----
    for p = 1:active
        paths(p).BIT = update_partial_sums(paths(p).BIT, phi, n);
    end
end

% ---- Select best path ----
[~, best] = min([paths.PM]);
u_hat = paths(best).BIT(n+1,:);
msg_hat = u_hat(info_pos);

end

function L = update_llr_tree(L, B, phi, n)

for lev = 1:n
    step = 2^(n-lev+1);
    half = step/2;

    for i = 1:step:size(L,2)
        for j = 0:half-1
            if mod(phi-1, step) < half
                % f-function
                a = L(lev, i+j);
                b = L(lev, i+j+half);
                L(lev+1, i+j) = sign(a).*sign(b).*min(abs(a), abs(b));
            else
                % g-function
                a = L(lev, i+j);
                b = L(lev, i+j+half);
                u = B(lev+1, i+j);
                L(lev+1, i+j+half) = b + (1-2*u).*a;
            end
        end
    end
end

end

function B = update_partial_sums(B, phi, n)

for lev = n:-1:1
    step = 2^(n-lev+1);
    half = step/2;

    for i = 1:step:size(B,2)
        for j = 0:half-1
            B(lev, i+j)      = mod(B(lev+1, i+j) + B(lev+1, i+j+half), 2);
            B(lev, i+j+half) = B(lev+1, i+j+half);
        end
    end
end

end
