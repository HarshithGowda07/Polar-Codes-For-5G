function [u_hat, msg_hat] = polar_sc_decode_strict(Lx, K)
% POLAR_SC_DECODE_STRICT
% Strict Arikan SC decoder for encoder:
%   u (natural) -> butterfly (F^{⊗n}) -> x_nat -> bit-reversal -> x
%
% INPUT:
%   Lx  : 1 x N LLRs of received bits, SAME order as transmitted x
%   K   : number of information bits
%
% OUTPUT:
%   u_hat   : 1 x N estimated u (natural order)
%   msg_hat : 1 x K estimated info bits
%
% Uses no polar built-ins, no bitrevorder.

    % ---------- basic params ----------
    Q = 1:32;                 % dummy reliability: 1..N, worst->best
    N = length(Lx);
    n = log2(N);

    Q1 = Q(Q <= N);

    % frozen/info positions in u (NATURAL order)
    F_u_idx    = Q1(1 : N-K);        % frozen positions
    info_u_idx = Q1(N-K+1 : end);    % info positions

    % build frozen mask for u
    frozenMask_u = false(1, N);
    frozenMask_u(F_u_idx) = true;

    % ---------- manual bit-reversal indices (same as encoder) ----------
    idx = zeros(1, N);
    for k = 0 : N-1
        rev = 0;
        for b = 1 : n
            rev = rev * 2 + bitget(k, b);   % LSB-first bit reversal
        end
        idx(k+1) = rev + 1;
    end

    % Encoder: x(p) = x_nat(idx(p))
    % To get LLRs of x_nat in natural order:
    %   L_nat(k) = Lx(p) where p s.t. idx(p) = k
    % Bit-reversal is self-inverse, so:
    L_nat = Lx(idx);

    % ---------- strict SC decoding for u (natural order) ----------
    % f and g in LLR domain (min-sum)
    f = @(a,b) (1-2*(a<0)).*(1-2*(b<0)).*min(abs(a),abs(b));
    g = @(a,b,c) b + (1-2*c).*a;

    u_hat = sc_decode_recursive(L_nat, frozenMask_u, f, g);

    % ---------- extract decoded info bits ----------
    msg_hat = u_hat(info_u_idx);
end


% ====== recursive strict SC decoder ======
function u = sc_decode_recursive(L, frozenMask, f, g)
    % L          : LLRs for this block (length N)
    % frozenMask : logical vector (length N) for this block
    %              true  -> frozen bit
    %              false -> info bit
    % f, g       : SC combining functions

    N = length(L);

    if N == 1
        % leaf corresponds to a single u_i
        if frozenMask
            u = 0;                    % frozen bit forced to 0
        else
            u = double(L < 0);        % info bit: hard decision from LLR
        end
    else
        N2 = N/2;

        % split L and frozen mask
        L1 = L(1:N2);
        L2 = L(N2+1:end);

        froz1 = frozenMask(1:N2);
        froz2 = frozenMask(N2+1:end);

        % left half: decode u1
        L_left = f(L1, L2);
        u1 = sc_decode_recursive(L_left, froz1, f, g);

        % right half: decode u2 (depends on u1)
        L_right = g(L1, L2, u1);
        u2 = sc_decode_recursive(L_right, froz2, f, g);

        % Arikan SC combine rule:
        % parent u = [u1 ⊕ u2, u2]
        u = [mod(u1 + u2, 2), u2];
    end
end
